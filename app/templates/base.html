<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vocalist</title>

  <!-- Bootstrap 5 -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
  <!-- htmx -->
  <script src="https://unpkg.com/htmx.org@1.9.12" defer></script>
  <!-- Supabase bootstrap (early) -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    // Injected by FastAPI
    window.SUPABASE_URL  = {{ supabase_url|tojson|safe }};
    window.SUPABASE_ANON = {{ supabase_anon_key|tojson|safe }};

    // Create the client ASAP so the magic-link callback can be handled
    window.sb = (window.SUPABASE_URL && window.SUPABASE_ANON && window.supabase)
      ? supabase.createClient(window.SUPABASE_URL, window.SUPABASE_ANON)
      : null;

    // Optional: log state changes so you can see SIGNED_IN after clicking the email link
    window.sb?.auth.onAuthStateChange((event, session) => {
      console.log('[auth]', event, !!session, session?.user?.email);
    });

    console.log('[boot]', 'url=', window.SUPABASE_URL, 'anon len=', (window.SUPABASE_ANON||'').length, 'sb=', !!window.sb);
  </script>

</head>
<body class="bg-light">
  <nav class="navbar bg-body-tertiary border-bottom">
    <div class="container">
      <a class="navbar-brand fw-bold" href="/">Vocalist</a>
      <span class="badge text-bg-secondary ms-auto" id="status">checking…</span>
    </div>
  </nav>

  <main class="container py-4">
    {% block content %}{% endblock %}
  </main>

  <div class="toast-container position-fixed top-0 end-0 p-3" id="toasts"></div>

  <script>
    // expose env to every page (safe-JSON encoded)
    window.SUPABASE_URL  = {{ supabase_url|tojson|safe }};
    window.SUPABASE_ANON = {{ supabase_anon_key|tojson|safe }};
    console.log('[boot] SUPABASE_URL=', window.SUPABASE_URL, 'ANON len=', (window.SUPABASE_ANON||'').length);
  </script>

  <script>
    // Make them globally available on every page
    window.SUPABASE_URL  = {{ supabase_url|tojson|safe }};
    window.SUPABASE_ANON = {{ supabase_anon_key|tojson|safe }};
  </script>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script>
  (function () {
    const root = document.getElementById('toasts');
    if (!root || !window.bootstrap) return;

    function showToast(payload) {
      const msg = typeof payload === 'string' ? payload : (payload && payload.message) || '';
      if (!msg) return;

      const wrap = document.createElement('div');
      wrap.className = 'toast align-items-center text-bg-dark border-0';
      wrap.role = 'status'; wrap.ariaLive = 'polite'; wrap.ariaAtomic = 'true';
      wrap.innerHTML = `
        <div class="d-flex">
          <div class="toast-body">${msg}</div>
          <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>`;
      root.appendChild(wrap);

      const t = new bootstrap.Toast(wrap, { delay: 1500 });
      t.show();
      wrap.addEventListener('hidden.bs.toast', () => wrap.remove());
    }

    // Listen for htmx-triggered custom events from the server
    document.body.addEventListener('toast', (e) => showToast(e.detail));
  })();
</script>

  <script>
    // Health badge
    fetch('/health')
      .then(r => r.json())
      .then(d => document.getElementById('status').textContent = d.status ?? 'unknown')
      .catch(() => document.getElementById('status').textContent = 'error');

    // --- Realtime STT → post final words to /input and update #word-list via htmx ---
(function () {
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const $status = document.getElementById('stt-status');
    const $start  = document.getElementById('btn-start');
    const $stop   = document.getElementById('btn-stop');
    const $live   = document.getElementById('live-transcript');

    if (!$start || !$stop) return; // page without STT panel

    if (!SpeechRecognition) {
      if ($status) $status.textContent = 'speech recognition not supported';
      if ($start)  $start.disabled = true;
      return;
    }

    const recog = new SpeechRecognition();
    recog.lang = 'en-AU';
    recog.interimResults = true;
    recog.continuous = true;
    recog.maxAlternatives = 1;

    function wordsFrom(text) {
      return text
        .toLowerCase()
        .replace(/[^a-z\u00C0-\u024f\s'-]/g, ' ')
        .trim()
        .split(/\s+/)
        .filter(Boolean);
    }

    function postWord(word) {
      htmx.ajax('POST', '/input', {
        values: { word },
        target: '#word-list',
        swap: 'innerHTML'
      });
    }

    let running = false;

    recog.onstart = () => {
      running = true;
      if ($status) $status.textContent = 'listening…';
      if ($start)  $start.disabled = true;
      if ($stop)   $stop.disabled = false;
    };
    recog.onerror = (e) => {
      if ($status) $status.textContent = 'error: ' + (e.error || 'unknown');
    };
    recog.onend = () => {
      running = false;
      if ($status) $status.textContent = 'stopped';
      if ($start)  $start.disabled = false;
      if ($stop)   $stop.disabled = true;
    };
    recog.onresult = (evt) => {
      let interim = '', finals = [];
      for (let i = evt.resultIndex; i < evt.results.length; i++) {
        const r = evt.results[i];
        const t = r[0].transcript;
        if (r.isFinal) finals.push(t);
        else interim += t + ' ';
      }
      if ($live) $live.textContent = interim.trim();
      finals.flatMap(wordsFrom).forEach(postWord);
    };

    // Public controls (so server can start/stop the mic)
    function startMic() { try { if (!running) recog.start(); } catch (e) {} }
    function stopMic()  { try { if (running)  recog.stop();  } catch (e) {} }

    window.vocalistMic = { start: startMic, stop: stopMic };

    // Buttons still work
    $start.addEventListener('click', startMic);
    $stop .addEventListener('click', stopMic);

    // Listen for server-triggered mic events via htmx HX-Trigger
    document.body.addEventListener('mic', (e) => {
      const action = e.detail && e.detail.action;
      if (action === 'start') startMic();
      if (action === 'stop')  stopMic();
    });
  })();
  </script>
</body>
</html>
